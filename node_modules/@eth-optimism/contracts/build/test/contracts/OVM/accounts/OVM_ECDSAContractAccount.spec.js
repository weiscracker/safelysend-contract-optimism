"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const setup_1 = require("../../../setup");
const hardhat_1 = require("hardhat");
const smock_1 = require("@eth-optimism/smock");
const constants_1 = require("../../../helpers/constants");
const helpers_1 = require("../../../helpers");
const callPrecompile = async (Helper_PrecompileCaller, precompile, functionName, functionParams, gasLimit) => {
    if (gasLimit) {
        return Helper_PrecompileCaller.callPrecompile(precompile.address, precompile.interface.encodeFunctionData(functionName, functionParams || []), { gasLimit });
    }
    return Helper_PrecompileCaller.callPrecompile(precompile.address, precompile.interface.encodeFunctionData(functionName, functionParams || []));
};
describe('OVM_ECDSAContractAccount', () => {
    let wallet;
    let badWallet;
    before(async () => {
        const provider = hardhat_1.waffle.provider;
        [wallet, badWallet] = provider.getWallets();
    });
    let Mock__OVM_ExecutionManager;
    let Helper_PrecompileCaller;
    before(async () => {
        Mock__OVM_ExecutionManager = await smock_1.smockit(await hardhat_1.ethers.getContractFactory('OVM_ExecutionManager'));
        Helper_PrecompileCaller = await (await hardhat_1.ethers.getContractFactory('Helper_PrecompileCaller')).deploy();
        Helper_PrecompileCaller.setTarget(Mock__OVM_ExecutionManager.address);
    });
    let Factory__OVM_ECDSAContractAccount;
    before(async () => {
        Factory__OVM_ECDSAContractAccount = await hardhat_1.ethers.getContractFactory('OVM_ECDSAContractAccount');
    });
    let OVM_ECDSAContractAccount;
    beforeEach(async () => {
        OVM_ECDSAContractAccount = await Factory__OVM_ECDSAContractAccount.deploy();
        Mock__OVM_ExecutionManager.smocked.ovmADDRESS.will.return.with(await wallet.getAddress());
        Mock__OVM_ExecutionManager.smocked.ovmCHAINID.will.return.with(420);
        Mock__OVM_ExecutionManager.smocked.ovmGETNONCE.will.return.with(100);
        Mock__OVM_ExecutionManager.smocked.ovmCALL.will.return.with([true, '0x']);
        Mock__OVM_ExecutionManager.smocked.ovmCREATE.will.return.with(constants_1.NON_ZERO_ADDRESS);
        Mock__OVM_ExecutionManager.smocked.ovmCALLER.will.return.with(constants_1.NON_ZERO_ADDRESS);
    });
    describe('fallback()', () => {
        it(`should successfully execute an EIP155Transaction`, async () => {
            const message = helpers_1.serializeNativeTransaction(helpers_1.DEFAULT_EIP155_TX);
            const sig = await helpers_1.signNativeTransaction(wallet, helpers_1.DEFAULT_EIP155_TX);
            await callPrecompile(Helper_PrecompileCaller, OVM_ECDSAContractAccount, 'execute', [
                message,
                0,
                `0x${sig.v}`,
                `0x${sig.r}`,
                `0x${sig.s}`,
            ]);
            const ovmCALL = Mock__OVM_ExecutionManager.smocked.ovmCALL.calls[1];
            setup_1.expect(ovmCALL._gasLimit).to.equal(helpers_1.DEFAULT_EIP155_TX.gasLimit);
            setup_1.expect(ovmCALL._address).to.equal(helpers_1.DEFAULT_EIP155_TX.to);
            setup_1.expect(ovmCALL._calldata).to.equal(helpers_1.DEFAULT_EIP155_TX.data);
            const ovmSETNONCE = Mock__OVM_ExecutionManager.smocked.ovmSETNONCE.calls[0];
            setup_1.expect(ovmSETNONCE._nonce).to.equal(helpers_1.DEFAULT_EIP155_TX.nonce + 1);
        });
        it(`should successfully execute an ETHSignedTransaction`, async () => {
            const message = helpers_1.serializeEthSignTransaction(helpers_1.DEFAULT_EIP155_TX);
            const sig = await helpers_1.signEthSignMessage(wallet, helpers_1.DEFAULT_EIP155_TX);
            await callPrecompile(Helper_PrecompileCaller, OVM_ECDSAContractAccount, 'execute', [
                message,
                1,
                `0x${sig.v}`,
                `0x${sig.r}`,
                `0x${sig.s}`,
            ]);
            const ovmCALL = Mock__OVM_ExecutionManager.smocked.ovmCALL.calls[1];
            setup_1.expect(ovmCALL._gasLimit).to.equal(helpers_1.DEFAULT_EIP155_TX.gasLimit);
            setup_1.expect(ovmCALL._address).to.equal(helpers_1.DEFAULT_EIP155_TX.to);
            setup_1.expect(ovmCALL._calldata).to.equal(helpers_1.DEFAULT_EIP155_TX.data);
            const ovmSETNONCE = Mock__OVM_ExecutionManager.smocked.ovmSETNONCE.calls[0];
            setup_1.expect(ovmSETNONCE._nonce).to.equal(helpers_1.DEFAULT_EIP155_TX.nonce + 1);
        });
        it(`should ovmCREATE if EIP155Transaction.to is zero address`, async () => {
            const createTx = Object.assign(Object.assign({}, helpers_1.DEFAULT_EIP155_TX), { to: '' });
            const message = helpers_1.serializeNativeTransaction(createTx);
            const sig = await helpers_1.signNativeTransaction(wallet, createTx);
            await callPrecompile(Helper_PrecompileCaller, OVM_ECDSAContractAccount, 'execute', [
                message,
                0,
                `0x${sig.v}`,
                `0x${sig.r}`,
                `0x${sig.s}`,
            ]);
            const ovmCREATE = Mock__OVM_ExecutionManager.smocked.ovmCREATE.calls[0];
            setup_1.expect(ovmCREATE._bytecode).to.equal(createTx.data);
        });
        it(`should revert on invalid signature`, async () => {
            const message = helpers_1.serializeNativeTransaction(helpers_1.DEFAULT_EIP155_TX);
            const sig = await helpers_1.signNativeTransaction(badWallet, helpers_1.DEFAULT_EIP155_TX);
            await callPrecompile(Helper_PrecompileCaller, OVM_ECDSAContractAccount, 'execute', [
                message,
                0,
                `0x${sig.v}`,
                `0x${sig.r}`,
                `0x${sig.s}`,
            ]);
            const ovmREVERT = Mock__OVM_ExecutionManager.smocked.ovmREVERT.calls[0];
            setup_1.expect(helpers_1.decodeSolidityError(ovmREVERT._data)).to.equal('Signature provided for EOA transaction execution is invalid.');
        });
        it(`should revert on incorrect nonce`, async () => {
            const alteredNonceTx = Object.assign(Object.assign({}, helpers_1.DEFAULT_EIP155_TX), { nonce: 99 });
            const message = helpers_1.serializeNativeTransaction(alteredNonceTx);
            const sig = await helpers_1.signNativeTransaction(wallet, alteredNonceTx);
            await callPrecompile(Helper_PrecompileCaller, OVM_ECDSAContractAccount, 'execute', [
                message,
                0,
                `0x${sig.v}`,
                `0x${sig.r}`,
                `0x${sig.s}`,
            ]);
            const ovmREVERT = Mock__OVM_ExecutionManager.smocked.ovmREVERT.calls[0];
            setup_1.expect(helpers_1.decodeSolidityError(ovmREVERT._data)).to.equal('Transaction nonce does not match the expected nonce.');
        });
        it(`should revert on incorrect chainId`, async () => {
            const alteredChainIdTx = Object.assign(Object.assign({}, helpers_1.DEFAULT_EIP155_TX), { chainId: 421 });
            const message = helpers_1.serializeNativeTransaction(alteredChainIdTx);
            const sig = await helpers_1.signNativeTransaction(wallet, alteredChainIdTx);
            await callPrecompile(Helper_PrecompileCaller, OVM_ECDSAContractAccount, 'execute', [
                message,
                0,
                `0x${sig.v}`,
                `0x${sig.r}`,
                `0x${sig.s}`,
            ]);
            const ovmREVERT = Mock__OVM_ExecutionManager.smocked.ovmREVERT.calls[0];
            setup_1.expect(helpers_1.decodeSolidityError(ovmREVERT._data)).to.equal('Transaction chainId does not match expected OVM chainId.');
        });
        it.skip(`should revert on insufficient gas`, async () => {
            const alteredInsufficientGasTx = Object.assign(Object.assign({}, helpers_1.DEFAULT_EIP155_TX), { gasLimit: 200000000 });
            const message = helpers_1.serializeNativeTransaction(alteredInsufficientGasTx);
            const sig = await helpers_1.signNativeTransaction(wallet, alteredInsufficientGasTx);
            await callPrecompile(Helper_PrecompileCaller, OVM_ECDSAContractAccount, 'execute', [
                message,
                0,
                `0x${sig.v}`,
                `0x${sig.r}`,
                `0x${sig.s}`,
            ], 40000000);
            const ovmREVERT = Mock__OVM_ExecutionManager.smocked.ovmREVERT.calls[0];
            setup_1.expect(helpers_1.decodeSolidityError(ovmREVERT._data)).to.equal('Gas is not sufficient to execute the transaction.');
        });
        it(`should revert if fee is not transferred to the relayer`, async () => {
            const message = helpers_1.serializeNativeTransaction(helpers_1.DEFAULT_EIP155_TX);
            const sig = await helpers_1.signNativeTransaction(wallet, helpers_1.DEFAULT_EIP155_TX);
            Mock__OVM_ExecutionManager.smocked.ovmCALL.will.return.with([false, '0x']);
            await callPrecompile(Helper_PrecompileCaller, OVM_ECDSAContractAccount, 'execute', [
                message,
                0,
                `0x${sig.v}`,
                `0x${sig.r}`,
                `0x${sig.s}`,
            ], 40000000);
            const ovmREVERT = Mock__OVM_ExecutionManager.smocked.ovmREVERT.calls[0];
            setup_1.expect(helpers_1.decodeSolidityError(ovmREVERT._data)).to.equal('Fee was not transferred to relayer.');
        });
    });
});
//# sourceMappingURL=OVM_ECDSAContractAccount.spec.js.map