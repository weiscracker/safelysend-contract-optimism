"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const setup_1 = require("../../../setup");
const hardhat_1 = require("hardhat");
const smock_1 = require("@eth-optimism/smock");
const core_utils_1 = require("@eth-optimism/core-utils");
const helpers_1 = require("../../../helpers");
const callPrecompile = async (Helper_PrecompileCaller, precompile, functionName, functionParams) => {
    return Helper_PrecompileCaller.callPrecompile(precompile.address, precompile.interface.encodeFunctionData(functionName, functionParams || []));
};
const addrToBytes32 = (addr) => '0x' + '00'.repeat(12) + core_utils_1.remove0x(addr.toLowerCase());
describe('OVM_ProxySequencerEntrypoint', () => {
    let wallet;
    before(async () => {
        const provider = hardhat_1.waffle.provider;
        [wallet] = provider.getWallets();
    });
    let Factory__OVM_ProxySequencerEntrypoint;
    before(async () => {
        Factory__OVM_ProxySequencerEntrypoint = await hardhat_1.ethers.getContractFactory('OVM_ProxySequencerEntrypoint');
    });
    let Mock__OVM_ExecutionManager;
    let Helper_PrecompileCaller;
    let OVM_SequencerEntrypoint;
    before(async () => {
        Mock__OVM_ExecutionManager = await smock_1.smockit(await hardhat_1.ethers.getContractFactory('OVM_ExecutionManager'));
        Mock__OVM_ExecutionManager.smocked.ovmCALLER.will.return.with(await wallet.getAddress());
        Mock__OVM_ExecutionManager.smocked.ovmEXTCODESIZE.will.return.with(0);
        Mock__OVM_ExecutionManager.smocked.ovmCHAINID.will.return.with(420);
        Helper_PrecompileCaller = await (await hardhat_1.ethers.getContractFactory('Helper_PrecompileCaller')).deploy();
        Helper_PrecompileCaller.setTarget(Mock__OVM_ExecutionManager.address);
        OVM_SequencerEntrypoint = await (await hardhat_1.ethers.getContractFactory('OVM_SequencerEntrypoint')).deploy();
    });
    let OVM_ProxySequencerEntrypoint;
    beforeEach(async () => {
        OVM_ProxySequencerEntrypoint = await Factory__OVM_ProxySequencerEntrypoint.deploy();
    });
    it(`should init the proxy with owner and implementation`, async () => {
        Mock__OVM_ExecutionManager.smocked.ovmSLOAD.will.return.with(`0x${'00'.repeat(32)}`);
        await callPrecompile(Helper_PrecompileCaller, OVM_ProxySequencerEntrypoint, 'init', [OVM_SequencerEntrypoint.address, await wallet.getAddress()]);
        const ovmSSTOREs = Mock__OVM_ExecutionManager.smocked.ovmSSTORE.calls;
        setup_1.expect(ovmSSTOREs[0]._key).to.equal(`0x${'00'.repeat(31)}01`);
        setup_1.expect(ovmSSTOREs[0]._value).to.equal(addrToBytes32(await wallet.getAddress()));
        setup_1.expect(ovmSSTOREs[1]._key).to.equal(`0x${'00'.repeat(32)}`);
        setup_1.expect(ovmSSTOREs[1]._value).to.equal(addrToBytes32(OVM_SequencerEntrypoint.address));
    });
    it(`should revert if proxy has already been inited`, async () => {
        Mock__OVM_ExecutionManager.smocked.ovmSLOAD.will.return.with(addrToBytes32(await wallet.getAddress()));
        await callPrecompile(Helper_PrecompileCaller, OVM_ProxySequencerEntrypoint, 'init', [core_utils_1.ZERO_ADDRESS, core_utils_1.ZERO_ADDRESS]);
        const ovmREVERT = Mock__OVM_ExecutionManager.smocked.ovmREVERT.calls[0];
        setup_1.expect(helpers_1.decodeSolidityError(ovmREVERT._data)).to.equal('ProxySequencerEntrypoint has already been inited');
    });
    it(`should allow owner to upgrade Entrypoint`, async () => {
        Mock__OVM_ExecutionManager.smocked.ovmSLOAD.will.return.with(addrToBytes32(await wallet.getAddress()));
        await callPrecompile(Helper_PrecompileCaller, OVM_ProxySequencerEntrypoint, 'upgrade', [`0x${'12'.repeat(20)}`]);
        const ovmSSTORE = Mock__OVM_ExecutionManager.smocked.ovmSSTORE.calls[0];
        setup_1.expect(ovmSSTORE._key).to.equal(`0x${'00'.repeat(32)}`);
        setup_1.expect(ovmSSTORE._value).to.equal(addrToBytes32(`0x${'12'.repeat(20)}`));
    });
    it(`should revert if non-owner tries to upgrade Entrypoint`, async () => {
        Mock__OVM_ExecutionManager.smocked.ovmSLOAD.will.return.with(`0x${'00'.repeat(32)}`);
        await callPrecompile(Helper_PrecompileCaller, OVM_ProxySequencerEntrypoint, 'upgrade', [`0x${'12'.repeat(20)}`]);
        const ovmREVERT = Mock__OVM_ExecutionManager.smocked.ovmREVERT.calls[0];
        setup_1.expect(helpers_1.decodeSolidityError(ovmREVERT._data)).to.equal('Only owner can upgrade the Entrypoint');
    });
    it(`successfully calls ovmCREATEEOA through Entrypoint fallback`, async () => {
        Mock__OVM_ExecutionManager.smocked.ovmSLOAD.will.return.with(addrToBytes32(OVM_SequencerEntrypoint.address));
        Mock__OVM_ExecutionManager.smocked.ovmDELEGATECALL.will.return.with([
            true,
            '0x',
        ]);
        const calldata = '0xdeadbeef';
        await Helper_PrecompileCaller.callPrecompile(OVM_ProxySequencerEntrypoint.address, calldata);
        const ovmDELEGATECALL = Mock__OVM_ExecutionManager.smocked.ovmDELEGATECALL.calls[0];
        setup_1.expect(ovmDELEGATECALL._address).to.equal(OVM_SequencerEntrypoint.address);
        setup_1.expect(ovmDELEGATECALL._calldata).to.equal(calldata);
    });
});
//# sourceMappingURL=OVM_ProxySequencerEntrypoint.spec.js.map