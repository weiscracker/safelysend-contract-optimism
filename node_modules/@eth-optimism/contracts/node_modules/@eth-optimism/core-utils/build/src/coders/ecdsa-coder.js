"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ctcCoder = exports.CTC_TX_GAS_PRICE_MULT_FACTOR = exports.ETH_SIGN_TX_FIELD_POSITIONS = exports.EIP155_TX_FIELD_POSITIONS = exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS = exports.SIGNATURE_FIELD_POSITIONS = exports.TX_TYPE_POSITION = exports.txTypePlainText = exports.TxType = void 0;
const common_1 = require("../common");
var TxType;
(function (TxType) {
    TxType[TxType["EIP155"] = 0] = "EIP155";
    TxType[TxType["EthSign"] = 1] = "EthSign";
})(TxType = exports.TxType || (exports.TxType = {}));
exports.txTypePlainText = {
    0: TxType.EIP155,
    1: TxType.EthSign,
    EIP155: TxType.EIP155,
    EthSign: TxType.EthSign,
};
exports.TX_TYPE_POSITION = { start: 0, end: 1 };
exports.SIGNATURE_FIELD_POSITIONS = {
    r: { start: 1, end: 33 },
    s: { start: 33, end: 65 },
    v: { start: 65, end: 66 },
};
exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS = {
    txType: exports.TX_TYPE_POSITION,
    sig: exports.SIGNATURE_FIELD_POSITIONS,
    gasLimit: { start: 66, end: 69 },
    gasPrice: { start: 69, end: 72 },
    nonce: { start: 72, end: 75 },
    target: { start: 75, end: 95 },
    data: { start: 95 },
};
exports.EIP155_TX_FIELD_POSITIONS = exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS;
exports.ETH_SIGN_TX_FIELD_POSITIONS = exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS;
exports.CTC_TX_GAS_PRICE_MULT_FACTOR = 1000000;
class DefaultEcdsaTxCoder {
    constructor(txType) {
        this.txType = txType;
    }
    encode(txData) {
        const txType = common_1.encodeHex(this.txType, common_1.getLen(exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS.txType));
        const r = common_1.toVerifiedBytes(txData.sig.r, common_1.getLen(exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS.sig.r));
        const s = common_1.toVerifiedBytes(txData.sig.s, common_1.getLen(exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS.sig.s));
        const v = common_1.encodeHex(txData.sig.v, common_1.getLen(exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS.sig.v));
        const gasLimit = common_1.encodeHex(txData.gasLimit, common_1.getLen(exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS.gasLimit));
        if (txData.gasPrice % exports.CTC_TX_GAS_PRICE_MULT_FACTOR !== 0) {
            throw new Error(`Gas Price ${txData.gasPrice} cannot be encoded`);
        }
        const gasPrice = common_1.encodeHex(txData.gasPrice / exports.CTC_TX_GAS_PRICE_MULT_FACTOR, common_1.getLen(exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS.gasPrice));
        const nonce = common_1.encodeHex(txData.nonce, common_1.getLen(exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS.nonce));
        const target = common_1.toVerifiedBytes(txData.target, common_1.getLen(exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS.target));
        if (txData.data.length % 2 !== 0) {
            throw new Error('Non-even hex string for tx data!');
        }
        const encoding = '0x' +
            txType +
            r +
            s +
            v +
            gasLimit +
            gasPrice +
            nonce +
            target +
            common_1.remove0x(txData.data);
        return encoding;
    }
    decode(txData) {
        txData = common_1.remove0x(txData);
        const sliceBytes = (position) => txData.slice(position.start * 2, position.end * 2);
        const pos = exports.DEFAULT_ECDSA_TX_FIELD_POSITIONS;
        if (parseInt(sliceBytes(pos.txType), 16) !== this.txType) {
            throw new Error('Invalid tx type');
        }
        return {
            sig: {
                r: common_1.add0x(sliceBytes(pos.sig.r)),
                s: common_1.add0x(sliceBytes(pos.sig.s)),
                v: parseInt(sliceBytes(pos.sig.v), 16),
            },
            gasLimit: parseInt(sliceBytes(pos.gasLimit), 16),
            gasPrice: parseInt(sliceBytes(pos.gasPrice), 16) * exports.CTC_TX_GAS_PRICE_MULT_FACTOR,
            nonce: parseInt(sliceBytes(pos.nonce), 16),
            target: common_1.add0x(sliceBytes(pos.target)),
            data: common_1.add0x(txData.slice(pos.data.start * 2)),
            type: this.txType,
        };
    }
}
class EthSignTxCoder extends DefaultEcdsaTxCoder {
    constructor() {
        super(TxType.EthSign);
    }
    encode(txData) {
        return super.encode(txData);
    }
    decode(txData) {
        return super.decode(txData);
    }
}
class Eip155TxCoder extends DefaultEcdsaTxCoder {
    constructor() {
        super(TxType.EIP155);
    }
    encode(txData) {
        return super.encode(txData);
    }
    decode(txData) {
        return super.decode(txData);
    }
}
function encode(data) {
    if (data.type === TxType.EIP155) {
        return new Eip155TxCoder().encode(data);
    }
    if (data.type === TxType.EthSign) {
        return new EthSignTxCoder().encode(data);
    }
    return null;
}
function decode(data) {
    if (Buffer.isBuffer(data)) {
        data = data.toString();
    }
    data = common_1.remove0x(data);
    const type = parseInt(data.slice(0, 2), 16);
    if (type === TxType.EIP155) {
        return new Eip155TxCoder().decode(data);
    }
    if (type === TxType.EthSign) {
        return new EthSignTxCoder().decode(data);
    }
    return null;
}
exports.ctcCoder = {
    eip155TxData: new Eip155TxCoder(),
    ethSignTxData: new EthSignTxCoder(),
    encode,
    decode,
};
//# sourceMappingURL=ecdsa-coder.js.map